#use <string>
#use <util>
#use <conio>

int hash1(string s) {
    int h = 5381;
    int len = string_length(s); // C0 helper function
    for (int i = 0; i < len; i++) {
        char c = string_charat(s, i); // C0 helper function
        h = ((h << 5) + h) + char_ord(c);
    }
    return h;
}
// Source: http://www.cse.yorku.ca/~oz/hash.html

int hash2(string s) {
    int h = 0;
    int len = string_length(s);
    
    for (int i = 0; i < len; i++) {
        char c = string_charat(s, i);
        // Logic: h = c + (h * 65599)
        // Implemented as: c + (h << 6) + (h << 16) - h
        h = char_ord(c) + (h << 6) + (h << 16) - h;
    }
    
    return h;
}
// Source: http://www.cse.yorku.ca/~oz/hash.html

int hash3(string s) {
    // FNV_OFFSET_BASIS for 32-bit (in hex to avoid signed int confusion)
    int h = 0x811C9DC5; 
    
    // FNV_PRIME for 32-bit
    int p = 16777619;   
    
    int len = string_length(s);
    
    for (int i = 0; i < len; i++) {
        char c = string_charat(s, i);
        
        // Step 1: XOR the hash with the character
        h = h ^ char_ord(c);
        
        // Step 2: Multiply by the FNV prime
        h = h * p;
    }
    
    return h;
}
// Source: http://www.isthe.com/chongo/tech/comp/fnv/

bool get_bit(int[] A, int i)
/*@requires 0 <= i && i/32 <  \length(A); @*/
{
    int index = i / 32;
    int a  = (1 << (i % 32)) & A[index];

    if (a == 0)
    {
        return false;
    }
    else
    {
        return true;
    }
    
}


void set_bit(int[] A, int i)
/*@requires 0 <= i && i/32 <  \length(A); @*/
/*@ensures get_bit(A, i); @*/
{
    // set the "xth" bit in A[] to 1
    int index = i / 32;

    A[index] = (1 << (i % 32)) | A[index];

}



// now to implement struct bloom


struct bloom_filter
{
    int limit;
    int[] data;
};


typedef struct bloom_filter* bloom_t;


bool is_bloom_expected_length(int length, int[] data) {
     //@assert \length(data) == length && length < int_max() / 8;
     return true;
}


bool is_bloom(bloom_t B) {
    return B!= NULL && is_bloom_expected_length(B->limit, B->data);
}


bloom_t bloom_new(int n)
/*@requires 0 < n && n /4 <  int_max(); @*/
/*@ensures \result != NULL; @*/ 
{
    bloom_t B = alloc(struct bloom_filter);
    B->limit = (n -1/ 32) + 1;
    B->data = alloc_array(int, (n - 1/32) + 1);
    return B;

}

/*
use the 3 hash functions above
also use set_bit and get_bit*/

bool bloom_contains(bloom_t B, string x)
/*@requires is_bloom(B);  @*/
{
    int index1 = abs(hash1(x)) % (B->limit * 32);
    int index2 = abs(hash2(x)) % (B->limit * 32);
    int index3 = abs(hash3(x)) % (B->limit * 32);
    return get_bit(B->data, index1) && 
      get_bit(B->data, index2) &&
      get_bit(B->data, index3);
}



void bloom_add(bloom_t B, string x) 
/*@requires is_bloom(B);  @*/
/*@ensures bloom_contains(B, x); @*/
{
    int index1 = abs(hash1(x)) % (B->limit * 32);
    // printf("index1 :%d\n", index1);
    int index2 = abs(hash2(x)) % (B->limit * 32);
    // printf("index12 :%d\n", index2);
    int index3 = abs(hash3(x)) % (B->limit * 32);
    // printf("index3 :%d\n", index3);
    set_bit(B->data, index1);
    set_bit(B->data, index2);
    set_bit(B->data, index3);

}

void print_bloom(bloom_t B)
/*@requires is_bloom(B);  @*/
{
    for (int i = 0; i < B->limit*32; i++)
    {
        if (get_bit(B->data, i))
        {
            printf("true ");
        }
        else
        {
            printf("false ");
        }
        
    }

    printf("\n");
    

}



